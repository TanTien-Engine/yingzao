import "editor.editor" for Editor
import "editor.node_cache" for NODE_CACHE
import "blueprint.blueprint" for Blueprint
import "blueprint.nodes.array" for Array
import "blueprint.nodes.subgraph" for Subgraph
import "blueprint.blackboard" for BLACKBOARD
import "archgraph.context" for CONTEXT
import "geograph.brush" for Brush
import "maths.vector" for Vector3

var RENDER_NODE_FILENAME = "9_assemble_draw.ves"

class Archeditor is Editor
{
	load()
	{
		super.load()

		this.prepare_nodes()

		this.all_geos = Array()

		import "archgraph.dou_gong" for DouGong

		this.dg = DouGong()
		CONTEXT.dg = this.dg

		this.render_node = nil
		this.add_node(NODE_CACHE.fetch("../yingzao/99_tools/%(RENDER_NODE_FILENAME)", nil), 0, 0)

		this.selected = nil
	}

	prepare_nodes()
	{
		this.clear_popup_nodes()

		import "archnodes" for ARCH_NODES
		for (var node in ARCH_NODES) {
			super.add_popup_node(node)
		}

		import "blueprint.nodes.commentary" for Commentary
		super.add_popup_node(Commentary)
	}

	rebuild_all_geos()
	{
		this.all_geos.list.clear()

		var scene = this.scene_stack.root()
		if (!scene.nodes.isEmpty) {
			this.dg.rebuild(scene, this.all_geos.list)
		}
	}

	set_brush_color(val, col)
	{
		if (val is Brush) {
			val.color.set(col.x, col.y, col.z)
		} else if (val is List) {
			for (var i in val) {
				this.set_brush_color(i.value.shape, col)
			}
		}
	}

	set_node_color(node, col)
	{
		import "archgraph.component.comp_node" for CompNode
		import "archgraph.tools.comp_ref" for CompRef

		if (!node) {
			return
		}

		var comp = nil
		if (node is CompNode) {
			comp = node.comp
		} else if (node is CompRef) {
			var v_comp = node.calc_value(0)
			if (v_comp) {
				comp = v_comp.value.comp
			}
		}

		if (comp) {
			this.set_brush_color(comp.v_geo.value.shape, col)
			this.set_brush_color(comp.v_geo_c.value.shape, col)
		}
	}

	draw_preview()
	{
		if (this.scene_stack.bp_dirty or CONTEXT.style_changed)
		{
			CONTEXT.style_changed = false
			
			this.rebuild_all_geos()

			Blueprint.send_pin_dirty_root(this.all_geos.exports[0])
		}

		var selected = this.preview_op.get_selected()
		if (selected != this.selected)
		{
			this.set_node_color(this.selected, Vector3(255, 255, 255))
			this.set_node_color(selected, Vector3(255, 0, 0))

			this.selected = selected

			Blueprint.send_pin_dirty_root(this.all_geos.exports[0])
		}

		super.draw_preview()

		if (this.render_node) {
			this.render_node.render_run()
		}	
	}

	add_node(bp_node, x, y)
	{
		import "archgraph.style.up_ang_angle" for UpAngAngle
		import "archgraph.style.step_length" for StepLength
		import "archgraph.tools.hori_conn" for HoriConn

		super.add_node(bp_node, x, y)

		if (bp_node is Subgraph and bp_node.filepath.contains(RENDER_NODE_FILENAME)) 
		{
			this.render_node = bp_node
			Blueprint.connect(this.all_geos, 0, this.render_node, 1)
		}
		else if (bp_node is UpAngAngle)
		{
			CONTEXT.s_up_ang_angle = bp_node
		}
		else if (bp_node is StepLength)
		{
			CONTEXT.s_step_len = bp_node
		}
		else if (bp_node is HoriConn)
		{
			this.dg.joints.add(bp_node)
		}
	}
}