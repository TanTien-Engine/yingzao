import "editor.editor" for Editor
import "editor.node_cache" for NODE_CACHE
import "blueprint.blueprint" for Blueprint
import "blueprint.nodes.array" for Array
import "blueprint.nodes.subgraph" for Subgraph
import "blueprint.blackboard" for BLACKBOARD
import "gonggraph.context" for CONTEXT
import "geograph.brush" for Brush
import "maths.vector" for Vector3

var RENDER_NODE_FILENAME = "9_assemble_draw.ves"

class Gongeditor is Editor
{
	load()
	{
		super.load()

		this.prepare_nodes()

		this.all_geos = Array()

		import "gonggraph.dou_gong" for DouGong

		this.dg = DouGong()
		CONTEXT.dg = this.dg

		this.render_node = nil
		this.add_node(NODE_CACHE.fetch("../yingzao/99_tools/%(RENDER_NODE_FILENAME)", nil), 0, 0)

		this.selected = nil
	}

	prepare_nodes()
	{
		this.clear_popup_nodes()

		import "gongnodes" for GONG_NODES
		for (var node in GONG_NODES) {
			super.add_popup_node(node)
		}

		import "blueprint.nodes.commentary" for Commentary
		super.add_popup_node(Commentary)

		import "blueprint.nodes.number" for Number
		super.add_popup_node(Number)
	}

	rebuild_all_geos()
	{
		import "gonggraph.component.comp_node" for CompNode

		this.all_geos.list.clear()

		var comp_nodes = []

		var scene = this.scene_stack.root()
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node and bp_node is CompNode) {
				comp_nodes.add(bp_node)
			}
		}

		if (!scene.nodes.isEmpty) {
			this.dg.rebuild(comp_nodes, this.all_geos.list)
		}
	}

	set_brush_color(val, col)
	{
		if (val is Brush) {
			val.set_color(col.x, col.y, col.z)
		} else if (val is List) {
			for (var i in val) {
				this.set_brush_color(i.value.shape, col)
			}
		}
	}

	set_node_color(node, col)
	{
		import "gonggraph.component.comp_node" for CompNode
		import "gonggraph.tools.comp_ref" for CompRef

		if (!node) {
			return
		}

		var comp = nil
		if (node is CompNode) {
			comp = node.comp
		} else if (node is CompRef) {
			var v_comp = node.calc_value(0)
			if (v_comp) {
				comp = v_comp.value.comp
			}
		}

		if (comp) {
			this.set_brush_color(comp.v_geo.value.shape, col)
			this.set_brush_color(comp.v_geo_c.value.shape, col)
		}
	}

	draw_preview()
	{
		if (this.scene_stack.bp_dirty or CONTEXT.style_changed)
		{
			CONTEXT.style_changed = false
			
			this.rebuild_all_geos()

			Blueprint.send_pin_dirty_root(this.all_geos.exports[0])
		}

		var selected = this.preview_op.get_selected()
		if (selected != this.selected)
		{
			this.set_node_color(this.selected, Vector3(255, 255, 255))
			this.set_node_color(selected, Vector3(255, 0, 0))

			this.selected = selected

			Blueprint.send_pin_dirty_root(this.all_geos.exports[0])
		}

		super.draw_preview()

		if (this.render_node) {
			this.render_node.render_run()
		}	
	}

	add_node(bp_node, x, y)
	{
		import "gonggraph.style.style_node" for StyleNode

		import "gonggraph.style.ang_slope" for AngSlope
		import "gonggraph.style.step_length" for StepLength
		import "gonggraph.tools.hori_conn" for HoriConn

		super.add_node(bp_node, x, y)

		if (bp_node is Subgraph and bp_node.filepath.contains(RENDER_NODE_FILENAME)) 
		{
			this.render_node = bp_node
			Blueprint.connect(this.all_geos, 0, this.render_node, 1)
		}
		else if (bp_node is AngSlope)
		{
			CONTEXT.s_ang_slope = bp_node
		}
		else if (bp_node is StepLength)
		{
			CONTEXT.s_step_len = bp_node
		}
		else if (bp_node is HoriConn)
		{
			this.dg.joints.add(bp_node)
		}
		else if (bp_node is StyleNode)
		{
			CONTEXT.style_nodes.add(bp_node)
		}
	}
}