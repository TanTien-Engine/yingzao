import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "geograph.nodes.knife" for Knife
import "geograph.nodes.translate_f" for TranslateF
import "scenegraph.nodes.transform3d" for Transform3d
import "archgraph.trans_nodes" for TransNodes
import "archgraph.node_helper" for NodeHelper
import "archgraph.constant" for ZU_CAI_HEIGHT
import "archgraph.nodes.vert_gong" for VertGong
import "archgraph.context" for CONTEXT
import "archgraph.gen_nodes" for GenNodes
import "archgraph.dou_helper" for DouHelper
import "archgraph.ang_tree" for AngTree
import "maths.vector" for Vector3
import "editor.node_cache" for NODE_CACHE
import "math" for Math

class Ang is VertGong
{
	init()
	{
		super.init()

		this.ang_layer = 0

		this.corner_others = []
		this.virt_tree = nil
	}

	calc_value(idx)
	{
		if (idx == 0)
		{
			var pos = this.calc_ang_pos()
			return Variant(Vector3(0, pos.y, 0))
		}
		else if (idx == 1)
		{
			var pos = this.calc_ang_pos()
			return Variant(pos)
		}
		else if (idx == 2)
		{
			var pos = NodeHelper.calc_curr_pos(this, 0)
			var z = - this.calc_inner_step_len()
			return Variant(pos.add(Vector3(0, ZU_CAI_HEIGHT, z)))
		}
	}

	resolve(dg)
	{
		var prev_outer_hop = 1
		var prev_inner_hop = 1

		var prev = Blueprint.get_input_node(this, 0)
		if (prev)
		{
			prev_outer_hop = prev.outer_hop
			prev_inner_hop = prev.inner_hop
			if (prev is Ang) {
				this.ang_layer = prev.ang_layer + 1
			}
		}

		this.outer_hop = prev_outer_hop + 1
		if (this.ang_layer == 0) {
			this.inner_hop = prev_inner_hop + 1
		} else if (this.ang_layer == 1) {
			this.inner_hop = prev_inner_hop		
		} else {
			this.inner_hop = 0
		}

		var ANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/37_ang.ves", nil)

		var ang_pos = this.calc_ang_pos()
		var v_geo = TransNodes.translate(ANG, ang_pos)

		if (this.ang_layer == 0)
		{
			import "archgraph.nodes.hua_gong" for HuaGong

			var pos = NodeHelper.calc_curr_pos(this, 0)
			var v_hua = HuaGong.create_geo(this.outer_hop, this.inner_hop, pos)

			// conn next
			v_hua = this.add_dou(v_hua, pos)

			// ang cut
			v_hua = this.ang_plane_cut(v_hua, true)

			v_geo = Variant([ v_hua, v_geo ])
		}
		else if (this.ang_layer == 1)
		{
			import "archgraph.nodes.shua_tou" for ShuaTou

			var pos = NodeHelper.calc_curr_pos(this, 0)
			var v_shua = ShuaTou.create_geo(this.outer_hop, this.inner_hop, pos)

			// conn next
			v_shua = this.add_dou(v_shua, pos)

			// ang cut
			var ang_0 = Blueprint.get_input_node(this, 0)
			v_shua = ang_0.ang_plane_cut(v_shua, true)

			v_geo = Variant([ v_shua, v_geo ])
		}

		this.comp.pos = ang_pos
		this.comp.v_geo = v_geo
		this.comp.v_geo_c = this.comp.v_geo

		this.virt_tree = AngTree(this, ang_pos)
		this.virt_tree.rebuild_layers()
	}

	resolve2(dg)
	{
		if (this.ang_layer != 0) {
			return
		}

		import "archgraph.nodes.fang" for Fang
		var FANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/13_fang.ves", nil)

		var a_pos = this.calc_ang_pos()
		a_pos.z = a_pos.z / 1.414

		for (var i in this.comp.y_idx .. dg.layers.count)
		{
			var layer = dg.layers[i]
			for (var j in 1 .. layer.count)
			{
				var node = layer[j]
				if (node.comp.x_idx == 0 and node is Fang)
				{
					var f_pos = NodeHelper.calc_curr_pos(node, 0)

					var v_fang = Blueprint.calc_output_value(FANG, 0)
					v_fang = node.add_dou(dg, v_fang, Vector3(0, 0, 0))

					v_fang = TransNodes.transform(VariantProxy(v_fang), f_pos, Math.pi() / 2)

					v_fang = Ang.ang_plane_cut(v_fang, true, a_pos)

					node.comp.v_geo_c = GenNodes.corner_gen_2(v_fang, Vector3(0, 0, 0), 0)
				}
			}
		}
	}

	get_title()
	{
		return "下昂%(this.ang_layer + 1)"
	}	
	
	calc_ang_pos()
	{
		import "archgraph.nodes.hua_gong" for HuaGong
		import "archgraph.nodes.shua_tou" for ShuaTou

		var dist = 0
		if (CONTEXT.gen_corner) {
			dist = CONTEXT.step_len_c_func(this.outer_hop, true)
		} else {
			dist = CONTEXT.step_len_func(this.outer_hop, true)
		}

		var prev = Blueprint.get_input_node(this, 0)
		if (prev is HuaGong or prev is ShuaTou)
		{
			var pos = Blueprint.calc_output_value(prev, 1).value
			return pos.add(Vector3(0, ZU_CAI_HEIGHT, dist))
		}
		else if (prev is Ang)
		{
			var pos = prev.calc_ang_pos()
			return pos.add(Vector3(0, ZU_CAI_HEIGHT * 0.5, dist))
		}
		else
		{
			return Vector3(0, 0, 0)
		}
	}

	ang_plane_cut(geo, down)
	{
		var ang_pos = this.calc_ang_pos()
		return Ang.ang_plane_cut(geo, down, ang_pos)	
	}

	static ang_plane_cut(geo, down, pos)
	{
		var ANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/37_ang.ves", nil)

		var KNIFE = Knife()
		if (down) {
			KNIFE.query_param("keep").set_value("below")
		} else {
			KNIFE.query_param("keep").set_value("above")
		}
		KNIFE.query_param("seam").set_value(true)

		var trans = Transform3d()
		if (down) {
			Blueprint.connect(ANG, "down_plane", trans, "obj")
		} else {
			Blueprint.connect(ANG, "up_plane", trans, "obj")
		}

		var pos_node = VariantProxy(Variant(pos))
		Blueprint.connect(pos_node, 0, trans, "translate")

		var geo_node = VariantProxy(geo)
		Blueprint.connect(geo_node, 0, KNIFE, "geo")
		Blueprint.connect(trans, "obj", KNIFE, "plane")
		return Blueprint.calc_output_value(KNIFE, "geo")		
	}
}