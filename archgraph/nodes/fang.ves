import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.variant_proxy" for VariantProxy
import "archgraph.variant" for PIN_TYPE_FANG, PIN_TYPE_HORI_GONG, PIN_TYPE_INNER_GONG
import "archgraph.trans_nodes" for TransNodes
import "archgraph.node_helper" for NodeHelper
import "archgraph.constant" for ZU_CAI_HEIGHT, CAI_HEIGHT
import "archgraph.component" for Component
import "archgraph.nodes.dou" for SAN_DOU, QIXIN_DOU
import "archgraph.joints_nodes" for JointsNodes
import "archgraph.gen_nodes" for GenNodes
import "archgraph.corner_helper" for CornerHelper
import "editor.node_cache" for NODE_CACHE
import "maths.vector" for Vector3
import "math" for Math

class Fang is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev", [ PIN_TYPE_FANG, PIN_TYPE_HORI_GONG, PIN_TYPE_INNER_GONG ]),
		]
		this.exports = [
			Pin(this, "next", [ PIN_TYPE_FANG ]),
		]

		this.layout()

		this.comp = Component()
	}

	calc_value(idx)
	{
		var pos = NodeHelper.calc_curr_pos(this, 0)
		return Variant(pos.add(Vector3(0, ZU_CAI_HEIGHT, 0)))
	}

	resolve(dg)
	{
		if (this.comp.x_idx == 0) {
			this.exports[0].type.add(PIN_TYPE_INNER_GONG)
		} else {
			this.exports[0].type.add(PIN_TYPE_HORI_GONG)
		}

		var FANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/13_fang.ves", nil)

		var pos = NodeHelper.calc_curr_pos(this, 0)

		var v_geo = TransNodes.translate(FANG, pos)

		// conn prev
		v_geo = this.add_joint(dg, v_geo, pos)

		// conn next
		v_geo = this.add_dou(dg, v_geo, pos)

		this.comp.pos = pos
		this.comp.v_geo = v_geo

		this.gen_corner(dg)
	}

	gen_corner(dg)
	{
		var FANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/13_fang.ves", nil)

		var pos = this.comp.pos

		import "archgraph.nodes.ang" for Ang
		if (this.comp.x_idx == 0 and dg.layers[this.comp.y_idx][0] is Ang) 
		{
			var ang_node = dg.layers[this.comp.y_idx][0]

			var ang_pos = ang_node.calc_ang_pos(false)

			var ANG = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/37_ang.ves", nil)				
			var v_geo = TransNodes.translate(ANG, ang_pos)

			var v_fang = Blueprint.calc_output_value(FANG, 0)
			v_fang = this.add_dou(dg, v_fang, Vector3(0, 0, 0))
			v_fang = TransNodes.transform(VariantProxy(v_fang), Vector3(0, pos.y, 0), Math.pi() / 2)

			v_fang = ang_node.ang_plane_cut(v_fang, true, false)

			v_geo = Variant([ v_fang, v_geo ])

			this.comp.v_geo_c = GenNodes.corner_gen_2(v_geo, Vector3(pos.x, 0, pos.z), 0)
		}
		else
		{
			var offset = 0
			if (this.comp.x_idx != 0)
			{
				var len_o = CornerHelper.calc_outer_len(this.comp.x_idx)
				var len_i = 2 - len_o
				offset = - (len_o - len_i) / 2
			}

			var v_geo = Blueprint.calc_output_value(FANG, 0)
			v_geo = this.add_dou(dg, v_geo, Vector3(0, 0, 0))
			this.comp.v_geo_c = GenNodes.corner_gen_2(v_geo, pos, offset)
		}
	}

	add_joint(dg, v_geo, pos)
	{
		var QIXIN_CUT  = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_qixin_cut_body.ves", nil)

		var has_c = !dg.has_vert_gong(this.comp.y_idx - 1)
		if (has_c) {
			return JointsNodes.cut_geo_node(v_geo, QIXIN_CUT, pos)		
		} else {
			return v_geo
		}
	}

	add_dou(dg, v_geo, pos)
	{
		var GD_SUN = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/10_gd_sun.ves", nil)

		var next = Blueprint.get_output_node(this, 0)
		if (!next) {
			return v_geo
		}

		import "archgraph.nodes.ya_cao_fang" for YaCaoFang
		if (next is YaCaoFang) {
			return v_geo
		}

		var l_pos = Vector3(-0.41, pos.y + CAI_HEIGHT, pos.z)
		var r_pos = Vector3( 0.41, pos.y + CAI_HEIGHT, pos.z)

		var l_sun = TransNodes.translate(GD_SUN, l_pos)
		var r_sun = TransNodes.translate(GD_SUN, r_pos)

		var l_dou = TransNodes.translate(SAN_DOU, l_pos)
		var r_dou = TransNodes.translate(SAN_DOU, r_pos)

		var has_c = !dg.has_vert_gong(this.comp.y_idx)
		if (has_c)
		{
			var c_pos = pos.add(Vector3(0, CAI_HEIGHT, 0))

			var c_sun = TransNodes.translate(GD_SUN, c_pos)
			var c_dou = TransNodes.translate(QIXIN_DOU, c_pos)

			v_geo = JointsNodes.cut_geo_node(v_geo, GD_SUN, [ l_pos, c_pos, r_pos ])

			return Variant([ v_geo, [ l_sun, c_sun, r_sun ], [ l_dou, c_dou, r_dou ] ])
		}
		else
		{
			v_geo = JointsNodes.cut_geo_node(v_geo, GD_SUN, [ l_pos, r_pos ])

			return Variant([ v_geo, [ l_sun, r_sun ], [ l_dou, r_dou ] ])
		}
	}

	get_title()
	{
		if (this.comp.x_idx == 0) {
			return "柱头方"
		} else {
			return "罗汉方"		
		}
	}
}