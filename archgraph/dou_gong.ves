import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.variant_proxy" for VariantProxy
import "geograph.variant" for VAR_TYPE_GEO
import "archgraph.node_helper" for NodeHelper
import "archgraph.context" for CONTEXT
import "archgraph.joints_nodes" for JointsNodes
import "editor.node_cache" for NODE_CACHE
import "maths.vector" for Vector2, Vector3
import "maths" for Maths
import "math" for Math

class DouGong
{
	init()
	{
		this.layers = []

		this.x_max = 0
		this.x_min = 0
	}

	rebuild(scene, out_list)
	{
		this.rebuild_layers(scene)

		// pass1: gen gong and dou
		for (var layer in this.layers) {
			for (var i in layer) {
				if (i) {
					i.resolve(this)
				}
			}
		}

		// pass2: fix corner dou
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node and bp_node.has_method("resolve2(_)")) {
				bp_node.resolve2(this)
			}
		}

		// joint
		for (var layer in this.layers) {
			this.build_layer_joints(layer)
			this.build_layer_side_joints(layer)
		}
		this.build_between_layers_joint()	

		// output
		if (CONTEXT.gen_corner) {
			this.get_result_geo_corner(out_list)		
		} else {
			this.get_result_geo(out_list)		
		}
	}

	get_result_geo(out_list)
	{
		for (var layer in this.layers)
		{
			for (var i in 1 .. layer.count) {
				out_list.add(layer[i].comp.v_geo)
			}
			if (layer[0]) {
				out_list.add(layer[0].comp.v_geo)
			}
		}
	}

	get_result_geo_corner(out_list)
	{
		for (var layer in this.layers)
		{
			for (var i in 1 .. layer.count) {
				out_list.add(layer[i].comp.v_geo_c)
			}
			if (layer[0]) {
				out_list.add(layer[0].comp.v_geo_c)
			}
		}
	}

	rebuild_layers(scene)
	{
		this.layers.clear()
		for (var i in 0..10) {
			this.layers.add([ nil ])
		}

		import "archgraph.nodes.vert_gong" for VertGong
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node and bp_node.has_method("resolve(_)"))
			{
				var layer = NodeHelper.calc_y_idx(bp_node)
				if (bp_node is VertGong) {
					this.layers[layer][0] = bp_node
				} else {
					this.layers[layer].add(bp_node)
				}

				bp_node.comp.y_idx = layer
			}
		}

		// set x_idx
		this.x_max = 0
		this.x_min = 0
		for (var layer in this.layers)
		{
			if (layer[0])
			{
				var o_idx = layer[0].comp.y_idx
				var o = Blueprint.get_output_node(layer[0], "outer")
				while (o) 
				{
					o.comp.x_idx = o_idx
					if (o_idx > this.x_max) {
						this.x_max = o_idx
					}
					o = Blueprint.get_output_node(o, 0)
				}

				var i_idx = -(layer[0].comp.y_idx)
				var i = Blueprint.get_output_node(layer[0], "inner")
				while (i) 
				{
					i.comp.x_idx = i_idx
					if (i_idx < this.x_min) {
						this.x_min = i_idx
					}
					i = Blueprint.get_output_node(i, 0)
				}
			}
		}

		// sort each layer
		for (var layer in this.layers)
		{
			if (layer.count > 2)
			{
				for (var i in 1 .. layer.count - 1) {
					for (var j in i + 1 .. layer.count) {
						if (layer[i].comp.x_idx < layer[j].comp.x_idx) {
							var tmp = layer[i]
							layer[i] = layer[j]
							layer[j] = tmp
						}
					}
				}
			}
		}
	}

	build_layer_joints(layer)
	{
		if (!layer[0]) {
			return
		}

		import "archgraph.nodes.ang" for Ang
		if (layer[0] is Ang and layer[0].ang_layer == 2) {
			return
		}

		// gong conn hua
		for (var i in 1 .. layer.count)
		{
			var pos = layer[i].comp.pos.clone()
			pos.y = pos.y + 0.1
			if (this.is_geo_contain(layer[0].comp.v_geo, pos))
			{
				var g2 = JointsNodes.conn2(layer[i].comp.v_geo, layer[0].comp.v_geo, layer[i].comp.pos, 0)
				layer[i].comp.v_geo = g2[0]
				layer[0].comp.v_geo = g2[1]
			}
		}

		// gong conn corner hua
		if (layer[0].comp.v_geo_c)
		{
			var CONN3_JOINT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/62_conn_3_joint.ves", nil)

			var angle = VariantProxy(Variant(Math.pi() / 4))

			for (var i in 1 .. layer.count)
			{
				var pos = layer[i].comp.pos.clone()
				pos.y = pos.y + 0.1
				if (layer[i].comp.v_geo_c and this.is_geo_contain(layer[0].comp.v_geo, pos))
				{
					var geo0 = VariantProxy(layer[i].comp.v_geo_c.value[0])
					var geo1 = VariantProxy(layer[i].comp.v_geo_c.value[1])					
					var geo2 = VariantProxy(layer[0].comp.v_geo_c)
					var pos  = VariantProxy(Variant(layer[i].comp.pos))

					Blueprint.connect(geo0,  0, CONN3_JOINT, "geo0")
					Blueprint.connect(geo1,  0, CONN3_JOINT, "geo1")
					Blueprint.connect(geo2,  0, CONN3_JOINT, "geo2")
					Blueprint.connect(pos,   0, CONN3_JOINT, "pos")
					Blueprint.connect(angle, 0, CONN3_JOINT, "angle")

					layer[i].comp.v_geo_c.value[0] = Blueprint.calc_output_value(CONN3_JOINT, "geo0")
					layer[i].comp.v_geo_c.value[1] = Blueprint.calc_output_value(CONN3_JOINT, "geo1")					
					layer[0].comp.v_geo_c = Blueprint.calc_output_value(CONN3_JOINT, "geo2")
				}
			}
		}
	}

	build_layer_side_joints(layer)
	{
		if (CONTEXT.gen_corner and layer.count > 2)
		{
			var dir0 = Vector2(0, -1)
			dir0.rotate(-Math.pi() / 4)

			var dir1 = Vector2(0, -1)
			dir1.rotate(Math.pi() / 4)

			for (var i in 1 .. layer.count - 1)
			{
				var x0 = layer[i].comp.pos.x
				var y0 = layer[i].comp.pos.z
				var a0 = [ x0, y0, x0 + dir0.x, y0 + dir0.y ]
				var a1 = [ x0, y0, x0 + dir1.x, y0 + dir1.y ]

				for (var j in i + 1 .. layer.count)
				{
					var x1 = layer[j].comp.pos.x
					var y1 = layer[j].comp.pos.z
					var b0 = [ x1, y1, x1 + dir0.x, y1 + dir0.y ]
					var b1 = [ x1, y1, x1 + dir1.x, y1 + dir1.y ]

					var c0 = Maths.get_line_intersect_line(b0, a1, false)
					var p0 = Vector3(c0[0], layer[i].comp.pos.y + 0.1, c0[1])
					if (c0 and this.is_geo_contain(layer[i].comp.v_geo_c.value[0], p0) and this.is_geo_contain(layer[j].comp.v_geo_c.value[1], p0))
					{
						var pos = Vector3(c0[0], layer[i].comp.pos.y, c0[1])
						var g2 = JointsNodes.conn2(layer[i].comp.v_geo_c.value[0], layer[j].comp.v_geo_c.value[1], pos, Math.pi() / 4)
						layer[i].comp.v_geo_c.value[0] = g2[0]
						layer[j].comp.v_geo_c.value[1] = g2[1]

						if (layer[j].comp.x_idx == 0 and layer[i].comp.x_idx + 1 == layer[j].comp.y_idx) 
						{
							 layer[j].comp.v_geo_c.value[1] = JointsNodes.cut_jao_hu_er(layer[j].comp.v_geo_c.value[1], pos, Math.pi() / 4)
						}
					}

					var c1 = Maths.get_line_intersect_line(b1, a0, false)
					var p1 = Vector3(c1[0], layer[i].comp.pos.y + 0.1, c1[1])
					if (c1 and this.is_geo_contain(layer[i].comp.v_geo_c.value[1], p1) and this.is_geo_contain(layer[j].comp.v_geo_c.value[0], p1))
					{
						var pos = Vector3(c1[0], layer[i].comp.pos.y, c1[1])
						var g2 = JointsNodes.conn2(layer[i].comp.v_geo_c.value[1], layer[j].comp.v_geo_c.value[0], pos, Math.pi() / 4)
						layer[i].comp.v_geo_c.value[1] = g2[0]
						layer[j].comp.v_geo_c.value[0] = g2[1]

						if (layer[j].comp.x_idx == 0 and layer[i].comp.x_idx + 1 == layer[j].comp.y_idx) 
						{
							 layer[j].comp.v_geo_c.value[0] = JointsNodes.cut_jao_hu_er(layer[j].comp.v_geo_c.value[0], pos, -Math.pi() / 4)
						}
					}
				}
			}
		}
	}

	build_lu_hua_joint()
	{
		import "archgraph.geo_helper" for GeoHelper

		if (this.layers[0].isEmpty) {
			return
		}

		if (CONTEXT.gen_corner)
		{
			if (this.layers[1][0])
			{
				var C_LU_CUT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_c_lu_cut_body.ves", nil)

				var hua = this.layers[1][0].comp
				hua.v_geo_c = GeoHelper.joint_cut_geo(hua.v_geo_c, C_LU_CUT, hua.pos)
			}
			if (this.layers[1].count > 1)
			{
				var LU_CUT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_lu_cut_body.ves", nil)
				var v_cut_geo = GeoHelper.rotate_geo(LU_CUT, Math.pi() / 4)
				var cut_node = VariantProxy(v_cut_geo)

				var nidao = this.layers[1][1].comp
				nidao.v_geo_c.value[1] = GeoHelper.joint_cut_geo(nidao.v_geo_c.value[1], cut_node, nidao.pos)
			}
		}
		else
		{
			if (this.layers[1][0])
			{
				var LU_CUT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_lu_cut_body.ves", nil)

				var hua = this.layers[1][0].comp
				hua.v_geo = GeoHelper.joint_cut_geo(hua.v_geo, LU_CUT, hua.pos)
			}
		}
	}

	build_between_layers_joint()
	{
		this.build_dou_er_joints()
		this.build_hori_gong_and_ang_joints()
	}

	build_dou_er_joints()
	{
		import "archgraph.geo_helper" for GeoHelper

		this.build_lu_hua_joint()

		for (var i in 1 .. this.layers.count - 1)
		{
			var hua = this.layers[i][0]
			if (hua)
			{
				var next_layer = this.layers[i + 1]
				var next_hua = next_layer[0].comp
				if (next_hua)
				{
					for (var j in 1 .. next_layer.count)
					{
						var h_gong = next_layer[j].comp
						if (h_gong.x_idx == hua.comp.y_idx or h_gong.x_idx == -(hua.comp.y_idx)) {
							next_hua.v_geo = JointsNodes.cut_jao_hu_er(next_hua.v_geo, h_gong.pos, 0)
						}
					}
				}
			}
		}
	}

	is_geo_contain(geo, pos)
	{
		if (geo.type == VAR_TYPE_ARRAY)
		{
			for (var i in geo.value) {
				if (this.is_geo_contain(i, pos)) {
					return true
				}
			}
		}
		else if (geo.type == VAR_TYPE_GEO)
		{
			return geo.value.shape.is_contain(pos.x, pos.y, pos.z)
		}
		return false
	}

	build_hori_gong_and_ang_joints()
	{
		import "archgraph.nodes.ang" for Ang

		for (var i in 0 .. this.layers.count)
		{
			var layer = this.layers[i]
			if (layer[0] is Ang) 
			{
				var ang = layer[0]

				var ang_geo = nil
				if (ang.ang_layer < 2) {
					ang_geo = ang.comp.v_geo.value.value[1]
				} else {
					ang_geo = ang.comp.v_geo
				}

				for (var j in 0 .. this.layers.count)
				{
					var layer = this.layers[j]
					for (var k in 1 .. layer.count)
					{
						var pos = layer[k].comp.pos
						if (this.is_geo_contain(ang_geo, Vector3(pos.x, pos.y + 0.15, pos.z)))
						{
							var gong = layer[k]

							var g2 = JointsNodes.conn2(gong.comp.v_geo, ang_geo, gong.comp.pos, 0)
							gong.comp.v_geo = g2[0]
							ang_geo = g2[1]
						}
						else if (this.is_geo_contain(ang_geo, Vector3(pos.x, pos.y, pos.z)))
						{
							var gong = layer[k]

							var g2 = JointsNodes.conn2(ang_geo, gong.comp.v_geo, gong.comp.pos, 0)
							ang_geo = g2[0]
							gong.comp.v_geo = g2[1]
						}
					}
				}
				
				if (ang.ang_layer < 2) {
					ang.comp.v_geo.value[1] = ang_geo
				} else {
					ang.comp.v_geo = ang_geo
				}
			}
		}
	}

	has_vert_gong(y_idx)
	{
		return this.layers[y_idx][0] != nil
	}

	has_hori_gong(y_idx, x_idx)
	{
		var layer = this.layers[y_idx]
		for (var i in 1 .. layer.count) {
			if (layer[i].comp.x_idx == x_idx) {
				return true
			}
		}

		return false
	}
}