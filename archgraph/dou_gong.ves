import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.variant_proxy" for VariantProxy
import "geograph.variant" for VAR_TYPE_GEO
import "archgraph.node_helper" for NodeHelper
import "editor.node_cache" for NODE_CACHE
import "maths.vector" for Vector3

class DouGong
{
	init()
	{
		this.layers = []

		this.x_max = 0
		this.x_min = 0
	}

	rebuild(scene, out_list)
	{
		this.rebuild_layers(scene)

		// resolve
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node and bp_node.has_method("resolve(_)")) {
				bp_node.resolve(this)
			}
		}

		// joint
		for (var layer in this.layers) {
			this.build_layer_joints(layer)
		}
		this.build_between_layers_joint()	

		// output
		for (var layer in this.layers)
		{
			for (var i in 1 .. layer.count) {
				out_list.add(layer[i].comp.v_geo)
			}
			if (layer[0]) {
				out_list.add(layer[0].comp.v_geo)
			}
		}
	}

	rebuild_layers(scene)
	{
		this.layers.clear()
		for (var i in 0..10) {
			this.layers.add([ nil ])
		}

		import "archgraph.nodes.vert_gong" for VertGong
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node and bp_node.has_method("resolve(_)"))
			{
				var layer = NodeHelper.calc_y_idx(bp_node)
				if (bp_node is VertGong) {
					this.layers[layer][0] = bp_node
				} else {
					this.layers[layer].add(bp_node)
				}

				bp_node.comp.y_idx = layer
			}
		}

		// set x_idx
		this.x_max = 0
		this.x_min = 0
		for (var layer in this.layers)
		{
			if (layer[0])
			{
				var o_idx = layer[0].comp.y_idx
				var o = Blueprint.get_output_node(layer[0], "outer")
				while (o) 
				{
					o.comp.x_idx = o_idx
					if (o_idx > this.x_max) {
						this.x_max = o_idx
					}
					o = Blueprint.get_output_node(o, 0)
				}

				var i_idx = -(layer[0].comp.y_idx)
				var i = Blueprint.get_output_node(layer[0], "inner")
				while (i) 
				{
					i.comp.x_idx = i_idx
					if (i_idx < this.x_min) {
						this.x_min = i_idx
					}
					i = Blueprint.get_output_node(i, 0)
				}
			}
		}
	}

	build_layer_joints(layer)
	{
		if (!layer[0]) {
			return
		}

		import "archgraph.nodes.ang" for Ang
		if (layer[0] is Ang and layer[0].ang_layer == 2) {
			return
		}

		var CONN2_JOINT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/62_conn_2_joint.ves", nil)
		for (var i in 1 .. layer.count)
		{
			var pos = layer[i].comp.pos.clone()
			pos.y = pos.y + 0.1
			if (this.is_geo_contain(layer[0].comp.v_geo, pos))
			{
				var geo0 = VariantProxy(layer[i].comp.v_geo)
				var geo1 = VariantProxy(layer[0].comp.v_geo)
				var pos  = VariantProxy(Variant(layer[i].comp.pos))

				Blueprint.connect(geo0, 0, CONN2_JOINT, "geo0")
				Blueprint.connect(geo1, 0, CONN2_JOINT, "geo1")
				Blueprint.connect(pos,  0, CONN2_JOINT, "pos")

				layer[i].comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo0")
				layer[0].comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo1")
			}
		}
	}

	build_lu_hua_joint()
	{
		import "archgraph.geo_helper" for GeoHelper

		if (this.layers[0].count <= 1 or !this.layers[1][0]) {
			return
		}

		var LU_CUT  = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_lu_cut_body.ves", nil)

		var hua = this.layers[1][0].comp
		hua.v_geo = GeoHelper.joint_cut_geo(hua.v_geo, LU_CUT, hua.pos)
	}

	build_between_layers_joint()
	{
		this.build_dou_er_joints()
		this.build_hori_gong_and_ang_joints()
	}

	build_dou_er_joints()
	{
		import "archgraph.geo_helper" for GeoHelper

		this.build_lu_hua_joint()

		var JIAOHU_CUT  = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/20_jiaohu_cut_body.ves", nil)

		for (var i in 1 .. this.layers.count - 1)
		{
			var hua = this.layers[i][0]
			if (hua)
			{
				var next_layer = this.layers[i + 1]
				var next_hua = next_layer[0].comp
				if (next_hua)
				{
					for (var j in 1 .. next_layer.count)
					{
						var h_gong = next_layer[j].comp
						if (h_gong.x_idx == hua.comp.y_idx or h_gong.x_idx == -(hua.comp.y_idx)) {
							next_hua.v_geo = GeoHelper.joint_cut_geo(next_hua.v_geo, JIAOHU_CUT, h_gong.pos)
						}
					}
				}
			}
		}
	}

	is_geo_contain(geo, pos)
	{
		if (geo.type == VAR_TYPE_ARRAY)
		{
			for (var i in geo.value) {
				if (this.is_geo_contain(i, pos)) {
					return true
				}
			}
		}
		else if (geo.type == VAR_TYPE_GEO)
		{
			return geo.value.shape.is_contain(pos.x, pos.y, pos.z)
		}
		return false
	}

	build_hori_gong_and_ang_joints()
	{
		import "archgraph.nodes.ang" for Ang

		var CONN2_JOINT = NODE_CACHE.fetch("C:/projects/yingzao/00_dougong2/62_conn_2_joint.ves", nil)

		for (var i in 0 .. this.layers.count)
		{
			var layer = this.layers[i]
			if (layer[0] is Ang) 
			{
				var ang =  layer[0]

				var ang_geo = nil
				if (ang.ang_layer < 2) {
					ang_geo = ang.comp.v_geo.value[1]
				} else {
					ang_geo = ang.comp.v_geo
				}

				for (var j in 0 .. this.layers.count)
				{
					var layer = this.layers[j]
					for (var k in 1 .. layer.count)
					{
						var pos = layer[k].comp.pos
						if (this.is_geo_contain(ang_geo, Vector3(pos.x, pos.y + 0.1, pos.z)))
						{
							var gong = layer[k]

							var geo0 = VariantProxy(gong.comp.v_geo)
							var geo1 = VariantProxy(ang_geo)
							var pos  = VariantProxy(Variant(gong.comp.pos))

							Blueprint.connect(geo0, 0, CONN2_JOINT, "geo0")
							Blueprint.connect(geo1, 0, CONN2_JOINT, "geo1")
							Blueprint.connect(pos,  0, CONN2_JOINT, "pos")

							gong.comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo0")
							if (ang.ang_layer < 2) {
								ang.comp.v_geo.value[1] = Blueprint.calc_output_value(CONN2_JOINT, "geo1")
							} else {
								ang.comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo1")
							}
						}
						else if (this.is_geo_contain(ang_geo, Vector3(pos.x, pos.y + 0.01, pos.z)))
						{
							var gong = layer[k]

							var geo0 = VariantProxy(ang_geo)
							var geo1 = VariantProxy(gong.comp.v_geo)
							var pos  = VariantProxy(Variant(gong.comp.pos))

							Blueprint.connect(geo0, 0, CONN2_JOINT, "geo0")
							Blueprint.connect(geo1, 0, CONN2_JOINT, "geo1")
							Blueprint.connect(pos,  0, CONN2_JOINT, "pos")

							if (ang.ang_layer < 2) {
								ang.comp.v_geo.value[1] = Blueprint.calc_output_value(CONN2_JOINT, "geo0")
							} else {
								ang.comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo0")
							}
							gong.comp.v_geo = Blueprint.calc_output_value(CONN2_JOINT, "geo1")
						}
					}
				}
				
			}
		}
	}

	has_vert_gong(y_idx)
	{
		return this.layers[y_idx][0] != nil
	}

	has_hori_gong(y_idx, x_idx)
	{
		var layer = this.layers[y_idx]
		for (var i in 1 .. layer.count) {
			if (layer[i].comp.x_idx == x_idx) {
				return true
			}
		}

		return false
	}
}