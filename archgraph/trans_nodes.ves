import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "geograph.nodes.rotate_y" for RotateY
import "geograph.nodes.translate_f" for TranslateF
import "editor.node_cache" for NODE_CACHE

fun get_geo_idx(geo_node)
{
	if (geo_node is VariantProxy) {
		return 0
	} else {
		return "geo"
	}
}

class TransNodes
{
	static rotate(geo_node, angle)
	{
		var rot_y = RotateY()
		Blueprint.connect(geo_node, get_geo_idx(geo_node), rot_y, 0)

		var angle_node = VariantProxy(Variant(angle))
		Blueprint.connect(angle_node.exports[0], rot_y.imports[1])

		return Blueprint.calc_output_value(rot_y, "geo")
	}

	static translate(geo_node, pos)
	{
		var trans = TranslateF()
		Blueprint.connect(geo_node, get_geo_idx(geo_node), trans, 0)

		var pos_node = VariantProxy(Variant(pos))
		Blueprint.connect(pos_node.exports[0], trans.imports[1])

		return Blueprint.calc_output_value(trans, "geo")
	}

	static transform(geo_node, pos, angle)
	{
		var rot_y = RotateY()
		Blueprint.connect(geo_node, get_geo_idx(geo_node), rot_y, 0)

		var angle_node = VariantProxy(Variant(angle))
		Blueprint.connect(angle_node.exports[0], rot_y.imports[1])

		var trans = TranslateF()
		Blueprint.connect(rot_y.exports[0], trans.imports[0])

		var pos_node = VariantProxy(Variant(pos))
		Blueprint.connect(pos_node.exports[0], trans.imports[1])

		return Blueprint.calc_output_value(trans, "geo")		
	}
}