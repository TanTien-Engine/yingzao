import "blueprint.blueprint" for Blueprint
import "maths.vector" for Vector3

class NodeHelper
{
	static calc_curr_pos(node, idx)
	{
		var v_pos = Blueprint.calc_input_value(node, idx)
		if (v_pos) {
			return v_pos.value
		} else {
			return Vector3(0, 0, 0)
		}
	}

	static calc_y_idx(node)
	{
		return this.calc_layer_impl(node, 0)
	}

	static calc_layer_impl(node, layer)
	{
		var prev = Blueprint.get_input_node(node, "prev")
		if (prev) 
		{
			import "archgraph.component.up_ang" for UpAng
			import "archgraph.component.beam" for Beam
			import "archgraph.tools.vert_split" for VertSplit
		
			if (prev is UpAng and Blueprint.get_input_pin(node, "prev").slot_idx == 2) {
				return this.calc_layer_impl(prev, layer + 2)
			} else if (prev is VertSplit or prev is Beam) {
				return this.calc_layer_impl(prev, layer)
			} else {
				return this.calc_layer_impl(prev, layer + 1)
			}
		} 
		else 
		{
			import "archgraph.tools.hori_merge" for HoriMerge

			var next = Blueprint.get_output_node(node, "next")
			if (next is HoriMerge) 
			{
				if (node is HoriMerge) {
					return 0
				} else {
					return this.calc_layer_impl(next, layer)
				}
			}
			return layer
		}
	}

	static get_output_valid_node(node, slot)
	{
		import "archgraph.tools.dummy_hori" for DummyHori

		var next = Blueprint.get_output_node(node, slot)
		if (!next or next is DummyHori) {
			return nil
		} else {
			return next
		}
	}

	static is_wide_beam_head(node, pos)
	{
		import "archgraph.component.beam" for Beam
		if (node is Beam and node.is_wide_head()) {
			return true
		}

		import "archgraph.tools.vert_merge" for VertMerge
		if (node is VertMerge)
		{
			var outer = Blueprint.get_input_node(node, "outer")
			if (outer is Beam and pos.z > 0 and outer.is_wide_head()) {
				return true
			}

			var inner = Blueprint.get_input_node(node, "inner")
			if (inner is Beam and pos.z < 0 and inner.is_wide_head()) {
				return true
			}
		}

		return false
	}
}