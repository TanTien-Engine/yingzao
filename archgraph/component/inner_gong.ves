import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.variant_proxy" for VariantProxy
import "editor.node_cache" for NODE_CACHE
import "archgraph.variant" for PIN_TYPE_INNER_GONG, PIN_TYPE_FANG
import "archgraph.constant" for CAI_HEIGHT, ZU_CAI_HEIGHT, DOU_H_WIDTH, MIN_GONG_SPACE
import "archgraph.trans_nodes" for TransNodes
import "archgraph.node_helper" for NodeHelper
import "archgraph.component" for Component
import "archgraph.component.dou" for SAN_DOU, JIAOHU_DOU
import "archgraph.context" for CONTEXT
import "archgraph.coord_trans" for CoordTrans
import "archgraph.dou_helper" for DouHelper
import "archgraph.spatial_query" for SpatialQuery
import "archgraph.joints_nodes" for JointsNodes
import "archgraph.gen_nodes" for GenNodes
import "geograph.nodes.brush_get_size" for BrushGetSize
import "maths.vector" for Vector3
import "math" for Math

var NI_DAO_GONG     = NODE_CACHE.fetch("../yingzao/00_dougong2/31_nidao_gong.ves", nil)
var BI_NEI_MAN_GONG = NODE_CACHE.fetch("../yingzao/00_dougong2/33_man_gong.ves", nil)

var GD_SUN = NODE_CACHE.fetch("../yingzao/00_dougong2/10_gd_sun.ves", nil)

var JIAOHU_CUT = NODE_CACHE.fetch("../yingzao/00_dougong2/20_jiaohu_tu_cut_body.ves", nil)
var QIXIN_CUT  = NODE_CACHE.fetch("../yingzao/00_dougong2/20_qixin_cut_body.ves", nil)

class InnerGong is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev", PIN_TYPE_INNER_GONG),
		]
		this.exports = [
			Pin(this, "next", PIN_TYPE_INNER_GONG),
		]

		this.layout()

		this.comp = Component()

		this.gong = nil
		this.dou_pos_x = nil
	}	

	calc_value(idx)
	{
		var pos = NodeHelper.calc_curr_pos(this, 0)
		return Variant(pos.add(Vector3(0, ZU_CAI_HEIGHT, 0)))
	}

	resolve(dg)
	{
		// select gong
		this.gong = this.select_gong()
		if (this.gong == BI_NEI_MAN_GONG) {
			this.exports[0].type = PIN_TYPE_FANG
		}

		// translate
		var pos = NodeHelper.calc_curr_pos(this, 0)
		var v_geo = TransNodes.translate(this.gong, pos)

		// conn prev
//		v_geo = this.add_joint(v_geo, prev, pos)

		// conn next
		v_geo = this.add_dou(dg, v_geo, pos, false, false)

		this.comp.pos = pos
		this.comp.v_geo = v_geo

		this.gen_corner(dg, false, false)
	}

	resolve2(dg)
	{
		var next_layer = nil
		if (dg.layers.count > this.comp.y_idx + 1) {
			next_layer = dg.layers[this.comp.y_idx + 1]
		}

		if (!next_layer) {
			return
		}

		var l_pos = CoordTrans.calc_hori_gong_rotated_pos(Vector3(this.dou_pos_x[0], this.comp.pos.y + ZU_CAI_HEIGHT + 0.14, this.comp.pos.z), this.comp.offset, Math.pi() / 4)
		var r_pos = CoordTrans.calc_hori_gong_rotated_pos(Vector3(this.dou_pos_x[1], this.comp.pos.y + ZU_CAI_HEIGHT + 0.14, this.comp.pos.z), this.comp.offset, Math.pi() / 4)

		var l_crossed = SpatialQuery.is_crossed(next_layer, l_pos)
		var r_crossed = SpatialQuery.is_crossed(next_layer, r_pos)
		if (l_crossed or r_crossed) {
			this.gen_corner(dg, l_crossed, r_crossed)
		}
	}

	gen_corner(dg, l_dou_jh, r_dou_jh)
	{
		var offset = 0
		if (this.gong == NI_DAO_GONG)
		{
			var outer = CONTEXT.step_len_func(1) + DOU_H_WIDTH
			var inner = CONTEXT.step_len_func(-1) + DOU_H_WIDTH
			var len_node = VariantProxy(Variant(outer + inner))
			Blueprint.connect(len_node, 0, this.gong, "length")

			offset = - (outer - inner) / 2		
		}
		else
		{
			var outer = CONTEXT.step_len_func(1) + CONTEXT.step_len_func(2) + DOU_H_WIDTH
			var inner = CONTEXT.step_len_func(-1) + CONTEXT.step_len_func(-2) - MIN_GONG_SPACE
			var len_node = VariantProxy(Variant(outer + inner))
			Blueprint.connect(len_node, 0, this.gong, "length")

			offset = - (outer - inner) / 2				
		}

		var v_geo = Blueprint.calc_output_value(this.gong, "geo")
		this.dou_pos_x = DouHelper.calc_dou_pos_x(v_geo)

		this.comp.offset = offset

		v_geo = this.add_dou(dg, v_geo, Vector3(0, 0, 0), l_dou_jh, r_dou_jh)
		this.comp.v_geo_c = GenNodes.corner_gen_2(v_geo, this.comp.pos, offset)			
	}

	select_gong()
	{
		var prev = Blueprint.get_input_node(this, 0)
		if (prev and prev is InnerGong) {
			return BI_NEI_MAN_GONG
		} else {
			return NI_DAO_GONG
		}
	}

	add_joint(v_geo, prev, pos)
	{
		var cut_node = nil
		if (prev and prev is InnerGong) {
			cut_node = QIXIN_CUT
		} else {
			cut_node = JIAOHU_CUT
		}

		return JointsNodes.cut_geo_node(v_geo, cut_node, pos)
	}

	add_dou(dg, v_geo, pos, l_dou_jh, r_dou_jh)
	{
		var next = Blueprint.get_output_node(this, 0)
		if (!next) {
			return v_geo
		}

		var dou_pos_x = DouHelper.calc_dou_pos_x(v_geo)
		var l_pos = Vector3(dou_pos_x[0], pos.y + CAI_HEIGHT, pos.z)
		var r_pos = Vector3(dou_pos_x[1], pos.y + CAI_HEIGHT, pos.z)

		var l_sun = TransNodes.translate(GD_SUN, l_pos)
		var r_sun = TransNodes.translate(GD_SUN, r_pos)

		var l_angle = 0
		var r_angle = 0

		var l_dou_node = SAN_DOU
		if (l_dou_jh) {
			l_dou_node = JIAOHU_DOU
			l_angle = Math.pi() * 0.5
		}
		var r_dou_node = SAN_DOU
		if (r_dou_jh) {
			r_dou_node = JIAOHU_DOU
			r_angle = Math.pi() * 0.5
		}

		var l_dou = TransNodes.transform(l_dou_node, l_pos, l_angle)
		var r_dou = TransNodes.transform(r_dou_node, r_pos, r_angle)

		// cut sun
		v_geo = JointsNodes.cut_geo_node(v_geo, GD_SUN, [ l_pos, r_pos ])

		return Variant([ v_geo, [ l_sun, r_sun ], [ l_dou, r_dou ] ])
	}

	get_title()
	{
		if (this.gong == NI_DAO_GONG) {
			return "泥道栱"
		} else {
			return "壁内慢栱"
		}
	}	
}