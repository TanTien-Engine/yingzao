import "blueprint.pin" for Pin
import "blueprint.node" for Node
import "blueprint.node_param" for NodeParam
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "blueprint.blueprint" for Blueprint
import "gonggraph.component.lu_dou" for LU_DOU
import "beamgraph.variant" for PIN_TYPE_CHUAN
import "beamgraph.comp_nodes" for CompNodes
import "beamgraph.gong_helper" for GongHelper
import "beamgraph.trans_nodes" for TransNodes
import "beamgraph.context" for CONTEXT
import "beamgraph.constant" for BEAM_DX, FRAME_DIST
import "beamgraph.chuan_helper" for ChuanHelper
import "maths.vector" for Vector3
import "math" for Math
import "editor.node_cache" for NODE_CACHE

class JiChuan is Node
{
	init()
	{
		super.init()

		this.exports = [
			Pin(this, "next", PIN_TYPE_CHUAN),
		]

		this.params.add(NodeParam("column", false))

		this.layout()

		this.deep = 0
		this.roof_height = 0
		this.base_height = 0

		this.max_deep = 0
	}

	resolve_deep(bf)
	{
		var column = this.query_param("column").value
		if (column) {
			bf.column_idx.add(0)
		}

		this.max_deep = ChuanHelper.calc_tree_deep(this)
	}

	resolve_height(bf)
	{
		this.base_height = ChuanHelper.calc_tree_base_height(this)

		this.roof_height = (this.max_deep * 2 * BEAM_DX + 0.3 * 2) / 3
	}

	resolve_geo(bf)
	{
		var pos = Vector3(0, this.base_height + this.roof_height, 0)
		var ret = [ CompNodes.create_chuan(pos) ]
//		var ret = []

		var dh = 0
		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			dh = this.roof_height - next.roof_height
		}

		var column = this.query_param("column").value
		if (column) {
			ret.add(this.create_column(bf, pos, dh))
		}

		var v_gong = nil
		if (CONTEXT.vert_conn and CONTEXT.gen_panjian) {
			v_gong = GongHelper.load_dou_gong("../yingzao/11_dg_song/802_pan_jian_2d.ves")
		} else {
			v_gong = GongHelper.load_dou_gong("../yingzao/11_dg_song/806_ding_hua_ji_chuan.ves")
		}

		if (v_gong) 
		{
			var h_gong = 0.06 + 0.21 + 0.21 + (0.12 - 0.02)
			v_gong = TransNodes.transform(VariantProxy(v_gong), Vector3(pos.x, pos.y - h_gong, pos.z), -Math.pi() * 0.5)

			if (dh > h_gong)
			{
				var h_column = dh - h_gong
				var v_column = this.create_zhuru_column(Vector3(pos.x, pos.y - dh + h_column, pos.z), h_column)
				ret.add(v_column)
			}
			
			ret.add(v_gong)
		}

		if (CONTEXT.hori_conn)
		{
			var off_h = 0.2
			var c = CompNodes.create_cha_shou(Vector3(pos.x, pos.y - off_h, pos.z), dh - off_h, BEAM_DX - 0.35)
			ret.add(c)
		}

		return Variant(ret)
	}

	resolve_pj_geo(bf, z)
	{
		var pos = Vector3(0, this.base_height + this.roof_height, 0)
		var h_gong = 0.06 + 0.21 + 0.21 + (0.12 - 0.02)

		var fang0 = CompNodes.create_pj_fang(Vector3(pos.x, pos.y - h_gong + 0.06, pos.z + z + FRAME_DIST * 0.5))
		var fang1 = CompNodes.create_pj_fang(Vector3(pos.x, pos.y - h_gong + 0.06 + 0.21, pos.z + z - FRAME_DIST * 0.5))

		return Variant([ fang0, fang1 ])
	}

	get_title()
	{
		return "脊椽"
	}

	create_column(bf, pos, dh)
	{
		var h_beam = 0.21
		var dou_h = 0.12

		var p = Vector3(pos.x, pos.y - dh - h_beam - dou_h, pos.z)

		var column = CompNodes.create_column(p, this.base_height + this.roof_height - dh - h_beam - dou_h)
		var dou = TransNodes.translate(LU_DOU, p)

		if (CONTEXT.vert_conn) {
			var e_fang = CompNodes.create_lan_e(p)
			return Variant([ dou, column, e_fang ])
		} else {
			return Variant([ dou, column ])
		}
	}

	create_zhuru_column(pos, height)
	{
		var COLUMN = NODE_CACHE.fetch("../yingzao/01_beam_column/10_column.ves", nil)

		var d = 0.2
		var radius_node = VariantProxy(Variant(d * 0.5))
		Blueprint.connect(radius_node, "out", COLUMN, "radius")	

		var h_node = VariantProxy(Variant(height))
		Blueprint.connect(h_node, "out", COLUMN, "height")

		Blueprint.connect(VariantProxy(Variant(true)), "out", COLUMN, "no_base")

		var ret = TransNodes.translate(COLUMN, Vector3(pos.x, pos.y, pos.z))

		h_node.disconnect()

		return ret
	}
}