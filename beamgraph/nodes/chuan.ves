import "blueprint.pin" for Pin
import "blueprint.node" for Node
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.node_param" for NodeParam
import "beamgraph.variant" for PIN_TYPE_CHUAN
import "beamgraph.constant" for BEAM_DX, BEAM_HEAD_LEN
import "beamgraph.comp_nodes" for CompNodes
import "beamgraph.context" for CONTEXT
import "maths.vector" for Vector3
import "math" for Math

class Chuan is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev", PIN_TYPE_CHUAN),
		]
		this.exports = [
			Pin(this, "next", PIN_TYPE_CHUAN),
		]

		this.params.add(NodeParam("l_column", true))
		this.params.add(NodeParam("r_column", true))

		this.layout()

		this.title = "槫"

		this.deep = 0
		this.height = 0
	}

	on_node_dirty()
	{
		CONTEXT.prop_changed = true
	}

	resolve(bf)
	{
		this.deep = this.calc_deep()

		var l_column = this.query_param("l_column").value
		if (l_column) {
			bf.column_idx.add(-this.deep)
		} 

		var r_column = this.query_param("r_column").value
		if (r_column) {
			bf.column_idx.add(this.deep)
		}
	}

	resolve2(bf)
	{
		this.title = this.calc_title(bf)

		this.height = this.calc_height(bf)

		var rot = -Math.pi() * 0.5
		var pos_l = Vector3(-BEAM_DX * this.deep, this.height, 0)
		var pos_r = Vector3( BEAM_DX * this.deep, this.height, 0)

		var geo_l = CompNodes.create_chuan(pos_l)
		var geo_r = CompNodes.create_chuan(pos_r)

		var ret = [ geo_l, geo_r ]

		var l_column = this.query_param("l_column").value
		if (l_column) {
			ret.add(CompNodes.create_column(pos_l, this.height))
		}
		var l_beam = this.create_left_beam(bf, this.deep, pos_l)
		if (l_beam) {
			ret.add(l_beam)
		}

		var r_column = this.query_param("r_column").value
		if (r_column) {
			ret.add(CompNodes.create_column(pos_r, this.height))
		}
		var r_beam = this.create_right_beam(bf, this.deep, pos_r)
		if (r_beam) {
			ret.add(r_beam)
		}

		return Variant(ret)
	}

	get_title()
	{
		return this.title	
	}

	calc_title(bf)
	{
		if (this.deep == 1) {
			return "上平槫"
		} else if (this.deep == bf.max_deep) {
			return "承椽槫"
		} else if (this.deep == bf.max_deep - 1) {
			return "下平槫"
		} else {
			return "中平槫"
		}
	}

	calc_deep()
	{
		var deep = 0

		var prev = Blueprint.get_input_node(this, "prev")
		while (prev) {
			deep = deep + 1
			prev = Blueprint.get_input_node(prev, "prev")
		}

		return deep
	}

	calc_height(bf)
	{
		if (this.deep == bf.max_deep) {
			return 0
		}

		var prev = Blueprint.get_input_node(this, "prev")
		if (prev)
		{
			var d = bf.max_deep - this.deep
			var dh = 0.1 * Math.pow(0.5, (this.deep - 1)) * bf.height
			return d / (d + 1) * prev.height - dh
		}
		else
		{
			return (bf.max_deep - this.deep) / bf.max_deep * bf.height
		}
	}

	calc_left_beam_dist(bf, idx)
	{
		var dist = -idx * 2
		for (var i in bf.column_idx)
		{
			if (i > idx) {
				var d = i - idx
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	calc_right_beam_dist(bf, idx)
	{
		var dist = idx * 2
		for (var i in bf.column_idx)
		{
			if (i < idx) {
				var d = idx - i
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	create_left_beam(bf, dist, pos)
	{
		var d = this.calc_left_beam_dist(bf, -dist)
//		if (d == dist * 2) {
//			return nil
//		}

		var h = this.calc_beam_height(d)
		var y = pos.y - h
		var len = d * BEAM_DX + BEAM_HEAD_LEN
		if (d == dist * 2) {
			len = len + BEAM_HEAD_LEN
		}

		return CompNodes.create_straight_beam(Vector3(pos.x - BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	create_right_beam(bf, dist, pos)
	{
		var d = this.calc_right_beam_dist(bf, dist)
		if (d == dist * 2) {
			return nil
		}

		var h = this.calc_beam_height(d)
		var y = pos.y - h
		var len = d * BEAM_DX + BEAM_HEAD_LEN
		return CompNodes.create_straight_beam(Vector3(pos.x - len + BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	calc_beam_height(deep)
	{
		if (deep <= 2) {
			return 0.24
		} else if (deep <= 4) {
			return 0.3
		} else {
			return 0.36
		}
	}
}