import "blueprint.pin" for Pin
import "blueprint.node" for Node
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.node_param" for NodeParam
import "blueprint.variant_proxy" for VariantProxy
import "gonggraph.component.dou" for Dou
import "gonggraph.component.lu_dou" for LuDou
import "gonggraph.component.inner_gong" for InnerGong
import "gonggraph.component.ti_mu" for TiMu
import "gonggraph.component.fang" for Fang
import "gonggraph.component.cheng_chuan_fang" for ChengChuanFang
import "gonggraph.component.shua_tou" for ShuaTou
import "gonggraph.component.beam" for Beam
import "gonggraph.component.hua_gong" for HuaGong
import "gonggraph.component.hori_gong" for HoriGong
import "gonggraph.component.liao_yan_fang" for LiaoYanFang
import "gonggraph.tools.hori_merge" for HoriMerge
import "gonggraph.tools.vert_merge" for VertMerge
import "beamgraph.variant" for PIN_TYPE_CHUAN
import "beamgraph.constant" for BEAM_DX, BEAM_HEAD_LEN
import "beamgraph.comp_nodes" for CompNodes
import "beamgraph.context" for CONTEXT
import "beamgraph.trans_nodes" for TransNodes
import "gonggraph.dou_gong" for DouGong
import "maths.vector" for Vector3
import "math" for Math

var YAN_FANG_HEIGHT_FIXED = 0.08

class Chuan is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev", PIN_TYPE_CHUAN),
		]
		this.exports = [
			Pin(this, "next", PIN_TYPE_CHUAN),
		]

		this.params.add(NodeParam("l_column", true))
		this.params.add(NodeParam("r_column", true))

		this.layout()

		this.title = "槫"

		this.deep = 0
		this.height = 0
	}

	on_node_dirty()
	{
		CONTEXT.prop_changed = true
	}

	resolve_deep(bf)
	{
		this.deep = this.calc_deep()

		var l_column = this.query_param("l_column").value
		if (l_column) {
			bf.column_idx.add(-this.deep)
		} 

		var r_column = this.query_param("r_column").value
		if (r_column) {
			bf.column_idx.add(this.deep)
		}
	}

	resolve_height(bf)
	{
		this.height = this.calc_height(bf)
	}

	resolve_geo(bf)
	{
		var ret = []

		this.title = this.calc_title(bf)

		var rot = -Math.pi() * 0.5
		var pos_l = Vector3(-BEAM_DX * this.deep, this.height, 0)
		var pos_r = Vector3( BEAM_DX * this.deep, this.height, 0)

		var sides = this.deep == bf.max_deep
		if (!sides) {
			ret.add(CompNodes.create_chuan(pos_l))
			ret.add(CompNodes.create_chuan(pos_r))
		}

		var l_column = this.query_param("l_column").value
		if (l_column) 
		{
			ret.add(this.create_column(bf, pos_l))
		} 
		else 
		{
			var next_beam_h = 0
			if (this.deep == bf.max_deep - 1) {
				var next = Blueprint.get_output_node(this, "next")
				if (next) {
					next_beam_h = next.calc_beam_height(next.calc_left_beam_dist(bf, -next.deep))
				}
			}
			ret.add(this.create_tuo_feng(bf, pos_l, next_beam_h))
		}
		if (sides) {
			ret.add(this.create_4s_dg(pos_l, false))
		} else {
			ret.add(this.create_3s_dg(pos_l, l_column))
			if (CONTEXT.cha_shou) {
				ret.add(this.create_tuo_jiao(bf, pos_l, false))			
			}
		}
		var l_beam = this.create_left_beam(bf, this.deep, pos_l)
		if (l_beam) {
			ret.add(l_beam)
		}

		var r_column = this.query_param("r_column").value
		if (r_column) 
		{
			ret.add(this.create_column(bf, pos_r))
		} 
		else 
		{
			var next_beam_h = 0
			if (this.deep == bf.max_deep - 1) {
				var next = Blueprint.get_output_node(this, "next")
				if (next) {
					next_beam_h = next.calc_beam_height(next.calc_right_beam_dist(bf, next.deep))
				}
			}
			ret.add(this.create_tuo_feng(bf, pos_r, next_beam_h))
		}
		if (sides) {
			ret.add(this.create_4s_dg(pos_r, true))
		} else {
			ret.add(this.create_3s_dg(pos_r, r_column))
			if (CONTEXT.cha_shou) {
				ret.add(this.create_tuo_jiao(bf, pos_r, true))			
			}
		}		
		var r_beam = this.create_right_beam(bf, this.deep, pos_r)
		if (r_beam) {
			ret.add(r_beam)
		}

		if (CONTEXT.yuan) {
			ret.add(this.create_yuan(bf))
		}

		return Variant(ret)
	}

	get_title()
	{
		return this.title	
	}

	calc_title(bf)
	{
		if (this.deep == 1) {
			return "上平槫"
		} else if (this.deep == bf.max_deep) {
			return "承椽槫"
		} else if (this.deep == bf.max_deep - 1) {
			return "下平槫"
		} else {
			return "中平槫"
		}
	}

	calc_deep()
	{
		var deep = 0

		var prev = Blueprint.get_input_node(this, "prev")
		while (prev) {
			deep = deep + 1
			prev = Blueprint.get_input_node(prev, "prev")
		}

		return deep
	}

	calc_height(bf)
	{
		if (this.deep == bf.max_deep) {
			return 0
		}

		var prev = Blueprint.get_input_node(this, "prev")
		if (prev)
		{
			var d = bf.max_deep - this.deep
			var dh = 0.1 * Math.pow(0.5, (this.deep - 1)) * bf.height
			return d / (d + 1) * prev.height - dh
		}
		else
		{
			return (bf.max_deep - this.deep) / bf.max_deep * bf.height
		}
	}

	create_column(bf, pos)
	{
		var h_gong = 0

		var sides = this.deep == bf.max_deep
		if (sides) {
			h_gong = this.calc_4s_gong_height()
		} else {
			h_gong = this.calc_3s_gong_height(true)		
		}

		return CompNodes.create_column(Vector3(pos.x, pos.y - h_gong, pos.z), this.height - h_gong)
	}

	calc_left_beam_dist(bf, idx)
	{
		var dist = -idx * 2
		for (var i in bf.column_idx)
		{
			if (i > idx) {
				var d = i - idx
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	calc_right_beam_dist(bf, idx)
	{
		var dist = idx * 2
		for (var i in bf.column_idx)
		{
			if (i < idx) {
				var d = idx - i
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	create_left_beam(bf, dist, pos)
	{
		var d = this.calc_left_beam_dist(bf, -dist)
//		if (d == dist * 2) {
//			return nil
//		}

		var h = this.calc_beam_height(d)
		var len = d * BEAM_DX + BEAM_HEAD_LEN
		if (d == dist * 2) {
			len = len + BEAM_HEAD_LEN
		}

		var y = 0
		var sides = this.deep == bf.max_deep
		if (sides) {
			y = pos.y - 0.21 * 2 - YAN_FANG_HEIGHT_FIXED
		} else {
			y = pos.y - h
		}

		return CompNodes.create_straight_beam(Vector3(pos.x - BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	create_right_beam(bf, dist, pos)
	{
		var d = this.calc_right_beam_dist(bf, dist)
		if (d == dist * 2) {
			return nil
		}

		var h = this.calc_beam_height(d)
		var len = d * BEAM_DX + BEAM_HEAD_LEN

		var y = 0
		var sides = this.deep == bf.max_deep
		if (sides) {
			y = pos.y - 0.21 * 2 - YAN_FANG_HEIGHT_FIXED
		} else {
			y = pos.y - h
		}

		return CompNodes.create_straight_beam(Vector3(pos.x - len + BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	calc_beam_height(deep)
	{
		//// chen tong
		//if (deep <= 2) {
		//	return 0.24
		//} else if (deep <= 4) {
		//	return 0.3
		//} else {
		//	return 0.36
		//}

		// chen ming da
		if (deep <= 1) {
			return 0.21
		} else if (deep <= 3) {
			return 0.3
		} else if (deep <= 5) {
			return 0.36
		} else {
			return 0.45
		}
	}

	create_tuo_feng(bf, pos, next_beam_h)
	{
		var dh = 0

		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			dh = this.height - next.height
		}

		var sides = this.deep == bf.max_deep - 1
		if (sides) {
			dh = dh + 0.21 * 2 - next_beam_h + YAN_FANG_HEIGHT_FIXED
		}

		return CompNodes.create_tuo_feng(Vector3(pos.x, pos.y - dh, pos.z), dh - this.calc_3s_gong_height(false))
	}

	calc_3s_gong_height(column)
	{
		var h_dou = 0
		if (column) {
			h_dou = 0.12
		} else {
			h_dou = 0.06
		}
		return h_dou + 0.21 + (0.12 - 0.02)
	}

	calc_4s_gong_height()
	{
		return 0.12 + 0.21 * 3 + YAN_FANG_HEIGHT_FIXED
	}

	create_3s_dg(pos, column)
	{
		var dou = nil
		if (column) {
			dou = LuDou()
		} else {
			dou = Dou()
		}

		var nodes = [ dou ]

		var gong = nil
		if (CONTEXT.pan_jian)
		{
			var g = InnerGong()
			var f = Fang()
			gong = HoriMerge()

			if (Math.mod(this.deep, 2) > 0) {
				Blueprint.connect(g, "next", gong, "left")
				Blueprint.connect(f, "next", gong, "right")
			} else {
				Blueprint.connect(f, "next", gong, "left")
				Blueprint.connect(g, "next", gong, "right")
			}

			nodes.add(g)
			nodes.add(f)
		}
		else
		{
			gong  = InnerGong()
		}
		nodes.add(gong)

		var ti = TiMu()
		nodes.add(ti)

		Blueprint.connect(dou, "hori", gong, "prev")
		Blueprint.connect(gong, "next", ti, "prev")

		var geos = []

		var dg = DouGong()
		dg.rebuild(nodes, geos)

		var v_gong = Variant(geos)

		var h_gong = this.calc_3s_gong_height(column)
		v_gong = TransNodes.transform(VariantProxy(v_gong), Vector3(pos.x, pos.y - h_gong, pos.z), -Math.pi() * 0.5)

		return v_gong
	}

	create_4s_dg(pos, rot)
	{
		var lu = LuDou()

		var ni_dao = InnerGong()
		var bi_man = InnerGong()
		var zhu_fang = Fang()
		var cheng_fang = ChengChuanFang()

		var hua = HuaGong()
		var shua = ShuaTou()		
		var ling = HoriGong()
		var yan = LiaoYanFang()

		Blueprint.connect(lu, "hori", ni_dao, "prev")
		Blueprint.connect(ni_dao, "next", bi_man, "prev")
		Blueprint.connect(bi_man, "next", zhu_fang, "prev")
		Blueprint.connect(zhu_fang, "next", cheng_fang, "prev")

		Blueprint.connect(lu, "vert", hua, "prev")
		Blueprint.connect(hua, "next", shua, "prev")

		Blueprint.connect(hua, "outer", ling, "prev")
		Blueprint.connect(ling, "next", yan, "prev")

		var geos = []

		var dg = DouGong()
		dg.rebuild([ lu, ni_dao, bi_man, zhu_fang, cheng_fang, shua, hua, ling, yan ], geos)

		var v_gong = Variant(geos)

		var h_gong = this.calc_4s_gong_height()

		var angle = -Math.pi() * 0.5
		if (rot) {
			angle = angle + Math.pi()
		}

		v_gong = TransNodes.transform(VariantProxy(v_gong), Vector3(pos.x, pos.y - h_gong, pos.z), angle)

		return v_gong
	}

	create_tuo_jiao(bf, pos, rot)
	{
		var dh = 0

		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			dh = this.height - next.height
		}

		if (this.deep == bf.max_deep - 1) {
			dh = dh + 0.21 + YAN_FANG_HEIGHT_FIXED
		}

		var off_h = 0.05
		return CompNodes.create_tuo_jiao(Vector3(pos.x, pos.y - off_h, pos.z), dh - off_h, BEAM_DX - 0.3, rot)
	}

	create_yuan(bf)
	{
		var prev = Blueprint.get_input_node(this, "prev")
		if (!prev) {
			return nil
		}

		var d = 0.08 * 2

		var l_p0 = Vector3(-BEAM_DX * this.deep, this.height + d, 0)
		var l_p1 = Vector3(-BEAM_DX * prev.deep, prev.height + d, 0)

		var ex_len = 0
		var ex_len_f = 0
		if (this.deep == bf.max_deep) 
		{
			var angle = Math.atan2(l_p1.y - l_p0.y, l_p1.x - l_p0.x)
			ex_len = (0.3 + 0.8) / Math.cos(angle)
			ex_len_f = (0.3 + 0.8 + 0.48) / Math.cos(angle)
		}

		var l_yuan = CompNodes.create_yuan(l_p0, l_p1, ex_len)

		// fei zi
		if (this.deep == bf.max_deep) 
		{
			var fei = CompNodes.create_fei_zi(l_p0, Vector3(l_p1.x, l_p1.y, l_p1.z), ex_len_f)
			l_yuan = Variant([ l_yuan, fei ])
		}

		var r_yuan = TransNodes.rotate(VariantProxy(l_yuan), Math.pi())

		var ret = []

		var num = 12
		var dist = 0.16
		for (var i in 0..num) {
			ret.add(TransNodes.translate(VariantProxy(Variant([l_yuan, r_yuan])), Vector3(0, 0, i * dist - (num - 1) * 0.5 * dist)))
		}

		return Variant(ret)
	}
}