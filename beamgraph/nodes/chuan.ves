import "blueprint.pin" for Pin
import "blueprint.node" for Node
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.node_param" for NodeParam
import "blueprint.variant_proxy" for VariantProxy
import "geograph.brush" for BrushInstanced
import "geograph.variant" for VAR_TYPE_GEO, VarGeo
import "gonggraph.component.dou" for Dou
import "gonggraph.component.lu_dou" for LuDou
import "gonggraph.component.inner_gong" for InnerGong
import "gonggraph.component.ti_mu" for TiMu
import "gonggraph.component.fang" for Fang
import "gonggraph.component.cheng_chuan_fang" for ChengChuanFang
import "gonggraph.component.shua_tou" for ShuaTou
import "gonggraph.component.beam" for Beam
import "gonggraph.component.hua_gong" for HuaGong
import "gonggraph.component.hori_gong" for HoriGong
import "gonggraph.component.liao_yan_fang" for LiaoYanFang
import "gonggraph.tools.hori_merge" for HoriMerge
import "gonggraph.tools.vert_merge" for VertMerge
import "gonggraph.tools_nodes" for ToolsNodes
import "beamgraph.variant" for PIN_TYPE_CHUAN
import "beamgraph.constant" for BEAM_DX, BEAM_HEAD_LEN, FRAME_DIST, YUAN_INSTANCED
import "beamgraph.comp_nodes" for CompNodes
import "beamgraph.context" for CONTEXT
import "beamgraph.trans_nodes" for TransNodes
import "gonggraph.dou_gong" for DouGong
import "maths.vector" for Vector3
import "math" for Math
import "maths" for Matrix44

var YAN_FANG_HEIGHT_FIXED = 0.09

class Chuan is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev", PIN_TYPE_CHUAN),
		]
		this.exports = [
			Pin(this, "next", PIN_TYPE_CHUAN),
		]

		this.params.add(NodeParam("l_column", true))
		this.params.add(NodeParam("r_column", true))

		this.layout()

		this.title = "槫"

		this.deep = 0
		this.roof_height = 0
		this.base_height = 0
	}

	on_node_dirty()
	{
		CONTEXT.prop_changed = true
	}

	resolve_deep(bf)
	{
		this.deep = this.calc_deep()

		var l_column = this.query_param("l_column").value
		if (l_column) {
			bf.column_idx.add(-this.deep)
		} 

		var r_column = this.query_param("r_column").value
		if (r_column) {
			bf.column_idx.add(this.deep)
		}
	}

	resolve_height(bf)
	{
		this.roof_height = 0
		this.base_height = 0

		var root = this.get_root_chuan()
		if (root) {
			this.base_height = root.base_height
		}
		
		if (this.is_curr_sides()) {
			this.roof_height = 0
			return
		}

		var deep = this.deep - root.deep

		var prev = Blueprint.get_input_node(this, "prev")
		if (prev)
		{
			var d = root.max_deep - deep
			var dh = 0.1 * Math.pow(0.5, (deep - 1)) * root.roof_height
			this.roof_height = d / (d + 1) * prev.roof_height - dh
		}
		else
		{
			this.roof_height = (root.max_deep - deep) / root.max_deep * root.roof_height
		}
	}

	resolve_geo(bf)
	{
		var ret = []

		this.title = this.calc_title(bf)

		var rot = -Math.pi() * 0.5
		var pos_l = Vector3(-BEAM_DX * this.deep, this.base_height + this.roof_height, 0)
		var pos_r = Vector3( BEAM_DX * this.deep, this.base_height + this.roof_height, 0)

		var sides = this.is_curr_sides()
		if (!sides) {
			ret.add(CompNodes.create_chuan(pos_l))
			ret.add(CompNodes.create_chuan(pos_r))
		}

		var l_column = this.query_param("l_column").value
		if (l_column) 
		{
			ret.add(this.create_column(bf, pos_l))
		} 
		else 
		{
			var next_beam_h = 0
			if (this.is_next_sides()) {
				var next = Blueprint.get_output_node(this, "next")
				if (next) {
					next_beam_h = next.calc_beam_height(next.calc_left_beam_dist(bf, -next.deep))
				}
			}
			ret.add(this.create_tuo_feng(bf, pos_l, next_beam_h))
		}
		if (sides) {
			ret.add(this.create_4s_dg(pos_l, false))
		} else {
			ret.add(this.create_3s_dg(pos_l, l_column))
			if (CONTEXT.hori_conn) {
				ret.add(this.create_tuo_jiao(bf, pos_l, false))			
			}
		}
		var l_beam = this.create_left_beam(bf, this.deep, pos_l)
		if (l_beam) {
			ret.add(l_beam)
		}

		var r_column = this.query_param("r_column").value
		if (r_column) 
		{
			ret.add(this.create_column(bf, pos_r))
		} 
		else 
		{
			var next_beam_h = 0
			if (this.is_next_sides()) {
				var next = Blueprint.get_output_node(this, "next")
				if (next) {
					next_beam_h = next.calc_beam_height(next.calc_right_beam_dist(bf, next.deep))
				}
			}
			ret.add(this.create_tuo_feng(bf, pos_r, next_beam_h))
		}

		if (sides) {
			ret.add(this.create_4s_dg(pos_r, true))
		} else {
			ret.add(this.create_3s_dg(pos_r, r_column))
			if (CONTEXT.hori_conn) {
				ret.add(this.create_tuo_jiao(bf, pos_r, true))			
			}
		}		
		var r_beam = this.create_right_beam(bf, this.deep, pos_r)
		if (r_beam) {
			ret.add(r_beam)
		}

		if (CONTEXT.yuan) {
			ret.add(this.create_yuan(bf))
		}

		if (!bf.shun_fu_chuan) {
			var chuan = this.create_shun_fu_chuan(bf)
			if (chuan) {
				ret.add(chuan)
				bf.shun_fu_chuan = true
			}
		}

		return Variant(ret)
	}

	resolve_pj_geo(bf, z)
	{
		var sides = this.is_curr_sides()
		if (sides) {
			return nil
		}

		var pos_l = Vector3(-BEAM_DX * this.deep, this.base_height + this.roof_height, 0)
		var pos_r = Vector3( BEAM_DX * this.deep, this.base_height + this.roof_height, 0)

		var l_column = this.query_param("l_column").value
		var r_column = this.query_param("r_column").value

		var dz = 0
		if (Math.mod(this.deep, 2) > 0) {
			dz = FRAME_DIST * 0.5
		} else {
			dz = -FRAME_DIST * 0.5
		}

		var dy = -(0.12 - 0.02)

		var fang_l = CompNodes.create_pj_fang(Vector3(pos_l.x, pos_l.y + dy, pos_l.z + z + dz))
		var fang_r = CompNodes.create_pj_fang(Vector3(pos_r.x, pos_r.y + dy, pos_r.z + z - dz))

		return Variant([ fang_l, fang_r ])
	}

	get_title()
	{
		return this.title	
	}

	calc_title(bf)
	{
		if (this.deep == 1) {
			return "上平槫"
		} else if (this.is_curr_sides()) {
			return "承椽槫"
		} else if (this.is_next_sides()) {
			return "下平槫"
		} else {
			return "中平槫"
		}
	}

	calc_deep()
	{
		var prev = Blueprint.get_input_node(this, "prev")
		if (prev) {
			return prev.deep + 1
		} else {
			return 0
		}
	}

	create_column(bf, pos)
	{
		var h_gong = 0

		var sides = this.is_curr_sides()
		if (sides) {
			h_gong = this.calc_4s_gong_height()
		} else {
			h_gong = this.calc_3s_gong_height(true)		
		}

		var p = Vector3(pos.x, pos.y - h_gong, pos.z)

		var column = CompNodes.create_column(p, this.base_height + this.roof_height - h_gong)
		if (CONTEXT.vert_conn) {
			var e_fang = CompNodes.create_lan_e_fang(p)
			return Variant([ column, e_fang ])
		} else {
			return column
		}
	}

	calc_left_beam_dist(bf, idx)
	{
		var dist = -idx * 2
		for (var i in bf.column_idx)
		{
			if (i > idx) {
				var d = i - idx
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	calc_right_beam_dist(bf, idx)
	{
		var dist = idx * 2
		for (var i in bf.column_idx)
		{
			if (i < idx) {
				var d = idx - i
				if (d < dist) {
					dist = d
				}
			}
		}
		return dist
	}

	create_left_beam(bf, dist, pos)
	{
		var d = this.calc_left_beam_dist(bf, -dist)
//		if (d == dist * 2) {
//			return nil
//		}

		var h = this.calc_beam_height(d)
		var len = d * BEAM_DX + BEAM_HEAD_LEN
		if (d == dist * 2) {
			len = len + BEAM_HEAD_LEN
		}

		var y = 0
		var sides = this.is_curr_sides()
		if (sides) {
			y = pos.y - 0.21 * 2 - YAN_FANG_HEIGHT_FIXED
		} else {
			y = pos.y - h
		}

		return CompNodes.create_straight_beam(Vector3(pos.x - BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	create_right_beam(bf, dist, pos)
	{
		var d = this.calc_right_beam_dist(bf, dist)
		if (d == dist * 2) {
			return nil
		}

		var h = this.calc_beam_height(d)
		var len = d * BEAM_DX + BEAM_HEAD_LEN

		var y = 0
		var sides = this.is_curr_sides()
		if (sides) {
			y = pos.y - 0.21 * 2 - YAN_FANG_HEIGHT_FIXED
		} else {
			y = pos.y - h
		}

		return CompNodes.create_straight_beam(Vector3(pos.x - len + BEAM_HEAD_LEN, y, pos.z), h, len)
	}

	calc_beam_height(deep)
	{
		//// chen tong
		//if (deep <= 2) {
		//	return 0.24
		//} else if (deep <= 4) {
		//	return 0.3
		//} else {
		//	return 0.36
		//}

		// chen ming da
		if (deep <= 1) {
			return 0.21
		} else if (deep <= 3) {
			return 0.3
		} else if (deep <= 5) {
			return 0.36
		} else {
			return 0.45
		}
	}

	create_tuo_feng(bf, pos, next_beam_h)
	{
		var dh = 0

		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			dh = this.roof_height - next.roof_height
		}

		var sides = this.is_next_sides()
		if (sides) {
			dh = dh + 0.21 * 2 - next_beam_h + YAN_FANG_HEIGHT_FIXED
		}

		return CompNodes.create_tuo_feng(Vector3(pos.x, pos.y - dh, pos.z), dh - this.calc_3s_gong_height(false))
	}

	calc_3s_gong_height(column)
	{
		var h_dou = 0
		if (column) {
			h_dou = 0.12
		} else {
			h_dou = 0.06
		}
		return h_dou + 0.21 + (0.12 - 0.02)
	}

	calc_4s_gong_height()
	{
		return 0.12 + 0.21 * 3 + YAN_FANG_HEIGHT_FIXED
	}

	create_3s_dg(pos, column)
	{
		var dou = nil
		if (column) {
			dou = LuDou()
		} else {
			dou = Dou()
		}

		var nodes = [ dou ]

		var gong = nil
		if (CONTEXT.vert_conn and CONTEXT.gen_panjian)
		{
			var g = InnerGong()
			var f = Fang()
			gong = HoriMerge()

			if (Math.mod(this.deep, 2) > 0) {
				Blueprint.connect(g, "next", gong, "left")
				Blueprint.connect(f, "next", gong, "right")
			} else {
				Blueprint.connect(f, "next", gong, "left")
				Blueprint.connect(g, "next", gong, "right")
			}

			nodes.add(g)
			nodes.add(f)
		}
		else
		{
			gong  = InnerGong()
		}
		nodes.add(gong)

		var ti = TiMu()
		nodes.add(ti)

		Blueprint.connect(dou, "hori", gong, "prev")
		Blueprint.connect(gong, "next", ti, "prev")

		var geos = []

		var dg = DouGong()
		dg.rebuild(nodes, geos)

		var v_gong = Variant(geos)

		var h_gong = this.calc_3s_gong_height(column)
		v_gong = TransNodes.transform(VariantProxy(v_gong), Vector3(pos.x, pos.y - h_gong, pos.z), -Math.pi() * 0.5)

		return v_gong
	}

	create_4s_dg(pos, rot)
	{
		var lu = LuDou()

		var ni_dao = InnerGong()
		var bi_man = InnerGong()
		var zhu_fang = Fang()
		var cheng_fang = ChengChuanFang()

		var hua = HuaGong()
		var shua = ShuaTou()		
		var ling = HoriGong()
		var yan = LiaoYanFang()

		Blueprint.connect(lu, "hori", ni_dao, "prev")
		Blueprint.connect(ni_dao, "next", bi_man, "prev")
		Blueprint.connect(bi_man, "next", zhu_fang, "prev")
		Blueprint.connect(zhu_fang, "next", cheng_fang, "prev")

		Blueprint.connect(lu, "vert", hua, "prev")
		Blueprint.connect(hua, "next", shua, "prev")

		Blueprint.connect(hua, "outer", ling, "prev")
		Blueprint.connect(ling, "next", yan, "prev")

		var geos = []

		var dg = DouGong()
		dg.rebuild([ lu, ni_dao, bi_man, zhu_fang, cheng_fang, shua, hua, ling, yan ], geos)

		var v_gong = Variant(geos)

		var h_gong = this.calc_4s_gong_height()

		var angle = -Math.pi() * 0.5
		if (rot) {
			angle = angle + Math.pi()
		}

		v_gong = TransNodes.transform(VariantProxy(v_gong), Vector3(pos.x, pos.y - h_gong, pos.z), angle)

		return v_gong
	}

	create_tuo_jiao(bf, pos, rot)
	{
		var dh = 0

		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			dh = this.roof_height - next.roof_height
		}

		if (this.is_next_sides()) {
			dh = dh + 0.21 + YAN_FANG_HEIGHT_FIXED
		}

		var off_h = 0.05
		return CompNodes.create_tuo_jiao(Vector3(pos.x, pos.y - off_h, pos.z), dh - off_h, BEAM_DX - 0.3, rot)
	}

	create_yuan(bf)
	{
		var prev = Blueprint.get_input_node(this, "prev")
		if (!prev) {
			return nil
		}

		var d = 0.08 * 2

		var l_p0 = Vector3(-BEAM_DX * this.deep, this.base_height + this.roof_height + d, 0)
		var l_p1 = Vector3(-BEAM_DX * prev.deep, prev.base_height + prev.roof_height + d, 0)

		var ex_len = 0
		var ex_len_f = 0
		if (this.is_curr_sides()) 
		{
			var angle = Math.atan2(l_p1.y - l_p0.y, l_p1.x - l_p0.x)
			ex_len = (0.3 + 0.8) / Math.cos(angle)
			ex_len_f = (0.3 + 0.8 + 0.48) / Math.cos(angle)
		}

		var l_yuan = CompNodes.create_yuan(l_p0, l_p1, ex_len)

		// fei zi
		if (this.is_curr_sides()) 
		{
			var fei = CompNodes.create_fei_zi(l_p0, Vector3(l_p1.x, l_p1.y, l_p1.z), ex_len_f)
			l_yuan = Variant([ l_yuan, fei ])
		}

		if (YUAN_INSTANCED)
		{
			l_yuan = ToolsNodes.brush_merge(l_yuan)

			var instanced = BrushInstanced()
			instanced.brush = l_yuan.value.shape

			var num = 17
			var dist = 0.16
			for (var i in 0..num) 
			{
				var l_mat = Matrix44.init()
				l_mat.translate(0, 0, i * dist - (num - 1) * 0.5 * dist)
				instanced.transforms.add(l_mat)

				var r_mat = Matrix44.init()
				r_mat.rotate(0, Math.pi(), 0)
				r_mat.translate(0, 0, i * dist - (num - 1) * 0.5 * dist)
				instanced.transforms.add(r_mat)
			}

			var geo = VarGeo()
			geo.shape = instanced

			return Variant(VAR_TYPE_GEO, geo)
		}
		else
		{
			var r_yuan = TransNodes.rotate(VariantProxy(l_yuan), Math.pi())

			var ret = []

			var num = 17
			var dist = 0.16
			for (var i in 0..num) {
				ret.add(TransNodes.translate(VariantProxy(Variant([l_yuan, r_yuan])), Vector3(0, 0, i * dist - (num - 1) * 0.5 * dist)))
			}

			return Variant(ret)
		}
	}

	create_shun_fu_chuan(bf)
	{
		var l_column = this.query_param("l_column").value
		var r_column = this.query_param("r_column").value
		if (!l_column or !r_column) {
			return nil
		}

		var next_cc = this.find_next_cc()
		if (!next_cc or next_cc.deep - this.deep <= 1) {
			return nil
		}

		var len = BEAM_DX * this.deep * 2
		var next_beam_h = next_cc.calc_beam_height(next_cc.calc_left_beam_dist(bf, -next_cc.deep))
		if (this.is_chuan_sides(next_cc)) {
			next_beam_h = next_beam_h + 0.21
		}
		return CompNodes.create_shun_fu_chuan(Vector3(-len * 0.5, next_cc.base_height + next_cc.roof_height - next_beam_h, 0), len)
	}

	find_next_cc()
	{
		import "beamgraph.nodes.sub_chuan" for SubChuan

		var curr = this
		while (curr) 
		{
			var next = Blueprint.get_output_node(curr, "next")
			if (!next or next is SubChuan) {
				return nil
			}

			var l_column = next.query_param("l_column").value
			var r_column = next.query_param("r_column").value
			if (l_column and r_column) {
				return next
			}

			curr = next
		}
		return nil
	}

	is_chuan_sides(chuan)
	{
		import "beamgraph.nodes.sub_chuan" for SubChuan

		var next = Blueprint.get_output_node(chuan, "next")
		return !next or next is SubChuan
	}

	is_curr_sides()
	{
		return this.is_chuan_sides(this)
	}

	is_next_sides()
	{
		var next = Blueprint.get_output_node(this, "next")
		if (next) {
			return this.is_chuan_sides(next)
		} else {
			return false
		}
	}

	get_root_chuan()
	{
		import "beamgraph.nodes.ji_chuan" for JiChuan
		import "beamgraph.nodes.sub_chuan" for SubChuan

		var prev = Blueprint.get_input_node(this, "prev")
		while (prev) {
			if (prev is JiChuan or prev is SubChuan) {
				return prev
			}
			prev = Blueprint.get_input_node(prev, "prev")
		}

		return nil
	}
}