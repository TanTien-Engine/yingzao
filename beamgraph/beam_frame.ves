import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "beamgraph.constant" for BEAM_DX, FRAME_DIST
import "beamgraph.trans_nodes" for TransNodes
import "maths.vector" for Vector3
import "math" for Math

class BeamFrame
{
	init()
	{
		this.column_idx = []

		this.max_deep = 0
		this.height = 0
	}

	rebuild(scene, out_list)
	{
		this.column_idx.clear()

		var comp_nodes = []
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node and bp_node.has_method("resolve_geo(_)")) {
				comp_nodes.add(bp_node)
			}
		}
		var sorted_nodes = Blueprint.topo_sort(comp_nodes)		

		// pass 1, deep
		for (var node in sorted_nodes) {
			node.resolve_deep(this)
		}

		// pass 2, height
		this.calc_height()
		for (var node in sorted_nodes) {
			node.resolve_height(this)
		}

		// pass 3, geo
		var geos = []
		for (var node in sorted_nodes) {
			geos.add(node.resolve_geo(this))
		}

		// copy
		for (var i in 0..3) 
		{
			var z = FRAME_DIST * i
			out_list.add(TransNodes.translate(VariantProxy(Variant(geos)), Vector3(0, 0, z)))

			if (Math.mod(i, 2) > 0) {
				for (var node in sorted_nodes) {
					out_list.add(node.resolve_pj_geo(this, z))
				}
			}
		}
	}

	calc_height()
	{
		this.max_deep = 0
		for (var i in this.column_idx) {
			if (i > this.max_deep) {
				this.max_deep = i
			}
		}

		this.height = (this.max_deep * 2 * BEAM_DX + 0.3 * 2) / 3
	}
}